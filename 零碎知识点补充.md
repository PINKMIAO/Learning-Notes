## 1.Mysql的上锁FOR UPDATE

在 MySQL 中，`FOR UPDATE` 是一种用于实现行级锁的 SQL 子句。它常见于事务处理中，尤其是在涉及多个事务并发执行时，用于保证数据的一致性和隔离性。理解 `FOR UPDATE` 上锁的作用和使用方式对于处理高并发场景中的数据一致性非常重要。

1. **作用和用途**

`FOR UPDATE` 的主要作用是在事务中对选定的行加锁，防止其他事务同时修改这些行。它通常与 `SELECT` 查询一起使用，用来在事务执行过程中锁定某些数据行，直到事务提交（`COMMIT`）或回滚（`ROLLBACK`）。

- **加锁类型**：`FOR UPDATE` 会对选定的行加 **排他锁**（exclusive lock），即使其他事务无法读取或修改这些行，直到当前事务提交或回滚。
- **事务控制**：通常在事务中使用，以确保事务期间的数据不被其他事务干扰，从而确保数据一致性。

2. **基本使用** 例子：

假设有一个名为 `accounts` 的表，包含两个字段 `account_id` 和 `balance`：

```sql
CREATE TABLE accounts (
    account_id INT PRIMARY KEY,
    balance DECIMAL(10, 2)
);
```

如果你在事务中想要对某些账户记录加锁，防止其他事务对这些记录进行修改，可以使用如下 SQL 语句：

```sql
START TRANSACTION;

-- 先查锁住，再更新
SELECT balance FROM accounts WHERE account_id = 1 FOR UPDATE;

-- 执行一些业务逻辑，比如更新账户余额
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

COMMIT;
```

在这个例子中：

1. `START TRANSACTION;` 开始一个事务。

2. `SELECT balance FROM accounts WHERE account_id = 1 FOR UPDATE;` 语句会选中 `account_id = 1` 的记录并加排他锁，防止其他事务修改该行数据。

3. 如果该事务完成了对余额的修改，调用 `COMMIT;` 提交事务。

4. **事务隔离级别与 `FOR UPDATE`**

   `FOR UPDATE` 的行为在不同的事务隔离级别下有所不同：

   - **READ COMMITTED**：此级别下，`FOR UPDATE` 会锁定当前查询到的行，但其他事务在查询过程中可以看到未提交的数据（脏读被防止）。

   - **REPEATABLE READ**：此级别下，`FOR UPDATE` 会锁定当前查询的行，并且在整个事务期间，其他事务无法修改这些行（即使是未提交的数据）。

   - **SERIALIZABLE**：此级别下，`FOR UPDATE` 会对整个查询涉及的记录加锁，确保事务串行执行，避免出现幻读（phantom read）等问题。

   通常，在高并发环境下，建议使用 `REPEATABLE READ` 或更高的隔离级别，以避免并发事务之间的数据冲突。



待研究锁类知识点。



## 2.curl、tenet、wget之间的区别

1. **curl**

- **功能**：`curl` 是一个强大的命令行工具，支持通过 URL 进行数据传输，可以使用各种协议，如 HTTP、HTTPS、FTP、SFTP、SMTP 等。它不仅可以用来下载文件，还可以用来上传文件、发送 POST 请求、设置请求头等。

- **特点**：

  - 支持多种协议（HTTP、HTTPS、FTP、SMTP 等）。
  - 支持文件上传和下载。
  - 支持请求头、cookies、代理、身份验证等。
  - 可以通过编程语言（如 Python、PHP 等）调用，适用于脚本编程。
  - 通常用于 API 测试和调试。

- **例子**：

  ```bash
  # 下载文件，文件以url上的file.zip命名
  curl -O http://example.com/file.zip
  # 模拟Post请求
  curl -X POST -d "key=value" http://example.com/api
  # 获取响应头信息
  curl -I https://example.com
  # 用IPv6调用
  curl -g http://[2001:1000::852]:9000
  ```
  
  -o 默认情况下，`curl` 会将下载的数据直接输出到标准输出（通常是终端），而不是保存为文件。要保存文件，必须使用 `-o` 或 `-O` 选项来指定输出文件名。`curl -o downloaded_file.txt https://example.com/file.txt`
  
  -g 选项用于禁用“通配符扩展”，避免将方括号 [] 视为通配符，并尝试匹配文件系统中的文件

2. **wget** “下载专用”工具

- **功能**：`wget` 主要用于从网络上下载文件，支持 HTTP、HTTPS 和 FTP 协议。它的特点是可以下载整个网站或递归下载文件，适合批量下载。

- **特点**：

  - 主要用于下载文件。
  - 支持递归下载、镜像站点、断点续传等功能。
  - 不如 `curl` 灵活，不支持 POST 请求和上传文件。
  - 默认会下载文件，并保存为原始文件名。

- **例子**：

  ```bash
  # 下载文件
  wget http://example.com/file.zip
  # 递归下载网站
  wget -r -np http://example.com/directory/
  # 断点续传
  wget -c https://example.com/file.zip
  ```

3. **tenet**

- 功能：`tenet`并不是一个常见的标准命令行工具。它可能是一个在某些特定环境中使用的工具，或者你可能是想提到`telnet`或其他某个类似的工具。

  - **telnet**：`telnet` 是一个用来连接远程主机的命令行工具，常用于测试和调试网络连接。它基于 TCP 协议，并允许用户连接到指定的端口。

  - **特点**：

    - 常用于网络调试，尤其是在指定的端口上测试服务。
    - 不用于文件传输或请求发送，更多的是测试端口和连接。

    ```bash
    # GET
    telnet example.com 80
    # POST
    tenet -X POST https://exmplease.com -d "key=value"
    ```

| 特性                   | **curl**                                       | **wget**                                   | **telnet**                                 |
| ---------------------- | ---------------------------------------------- | ------------------------------------------ | ------------------------------------------ |
| **主要功能**           | 支持多协议的文件传输，发送 HTTP 请求，API 调试 | 用于下载文件，支持递归下载、镜像功能       | 用于测试网络连接，连接远程主机的端口       |
| **支持的协议**         | HTTP, HTTPS, FTP, SFTP, SMTP 等多种协议        | HTTP, HTTPS, FTP 等基本协议                | 主要基于 TCP 协议，通常用于端口测试        |
| **是否支持 POST 请求** | 支持                                           | 不支持                                     | 不支持                                     |
| **是否支持上传文件**   | 支持                                           | 不支持                                     | 不支持                                     |
| **递归下载**           | 不支持                                         | 支持（可以下载整个网站或目录）             | 不支持                                     |
| **断点续传**           | 支持                                           | 支持                                       | 不支持                                     |
| **使用场景**           | 文件下载、上传，API 调试，测试 HTTP 请求       | 主要用于下载文件，适合批量下载或下载大文件 | 网络调试，测试端口是否开放，检查服务器响应 |
| **示例命令**           | `curl -O http://example.com/file.zip`          | `wget http://example.com/file.zip`         | `telnet example.com 80`                    |

其中：

- **断点续传**（Resume Download 或者 Resumable Download）是指在下载过程中，如果下载中途因为某种原因（如网络中断、客户端关闭等）停止了，可以从上次下载停止的地方继续下载，而不是从头开始下载整个文件。

- **`wget`**：`wget` 支持断点续传的功能，默认情况下，如果你再次下载一个已经下载过部分的文件，它会自动从下载中断的地方继续下载。

  ```bash
  wget -c http://example.com/largefile.zip
  ```

  就是失败了，再次执行相同命令，他会继续下载，不会从头开始。



## 3.什么是DNS？

DNS（**Domain Name System**）是域名系统，用于将域名（如`www.example.com`）解析为IP地址（如`192.168.1.1`）。

DNS的主要作用是让用户能够通过容易记住的域名访问互联网上的服务器，而不是直接使用IP地址。

通俗来说，**DNS（域名系统）**的作用就是“翻译”域名。

就像我们在生活中使用名字来称呼某个人，但**电脑和服务器只认识数字地址（IP 地址）**。所以，**DNS 就是一个翻译器**，它将我们输入的域名（比如 `www.baidu.com`）翻译成电脑能理解的数字地址（比如 `10.1.12.127`）。

这样，当你在浏览器输入 `www.baidu.com`，DNS 会告诉浏览器“嘿，这个网站的真实地址是 `10.1.12.127`”，然后浏览器就能找到那个服务器，开始加载网站。

总结一下，DNS 就是让人类能用容易记的名字来访问网站，而背后则通过数字地址来进行实际连接。当一个域名连DNS也找不到IP的时候，直接配置在hosts里面就行了，比如localhsot等

1. **域名解析的过程**：（假设）
   - 当你在浏览器中输入 `www.baidu.com` 时，首先你需要将这个**域名**（`www.baidu.com`）转换为对应的**IP地址**（比如：`220.181.57.216`）。
   - 这个转换过程就是通过 **DNS（域名系统）** 来完成的。
2. **如何通过DNS找到IP地址**：
   - 你的计算机**首先**会检查配置文件中设置的DNS服务器（比如：`DNS1=192.168.30.1`）。
   - 然后，它会向DNS服务器发出请求，询问 `www.baidu.com` 对应的IP地址。
   - DNS服务器会查询自己数据库中的记录，找到 `www.baidu.com` 对应的IP地址（例如：`220.181.57.216`），并将结果返回给你的计算机。最终访问的路径就是`http://192.168.30.1`
3. **访问过程**：
   - 一旦你获得了 `www.baidu.com` 的IP地址（比如：`220.181.57.216`），你的计算机会直接向这个IP地址发起连接请求（通过路由器和网关等网络设备）。
   - 然后，百度的服务器就会根据你的请求返回网页内容，最终展示在你的浏览器中。



**域名解析的详细过程：**

当你在浏览器中输入 `www.baidu.com` 并按下回车时，计算机会通过一系列步骤去找到这个域名对应的IP地址。具体过程如下：

1. **查看本地缓存**

   - 计算机会首先检查自己的本地缓存（Local DNS Cache），看看是否之前已经解析过 `www.baidu.com`，并且缓存中有没有对应的IP地址。如果有，计算机会直接使用这个IP地址来进行访问。

   - 如果没有，计算机会进入下一步。

2. **请求本地DNS服务器**

   - 如果本地没有缓存的结果，计算机会将域名解析请求**发送**到你当前网络配置中的**DNS服务器**，**通常是由你的互联网服务提供商（ISP）提供的**。也就是你路由器或网络设置中指定的DNS服务器（比如：`8.8.8.8`，`1.1.1.1`，或者本地ISP的DNS）。

   - 这个DNS服务器的作用是接收你发出的请求，并通过DNS系统继续查询。

3. **DNS递归查询**

   - 本地DNS服务器会开始进行递归查询。这意味着它会通过多级的DNS服务器逐步寻找最终的IP地址。具体过程是：

   - **查询根DNS服务器**：
     - 首先，DNS服务器会联系**根DNS服务器**。根DNS服务器并不直接存储所有域名的信息，它们知道如何指向下一级的顶级域（TLD）服务器，比如 `.com`、`.org`、`.cn` 等。
     - 例如，根DNS服务器会告诉你的本地DNS服务器，`www.baidu.com` 属于 `.com` 顶级域，因此它会指向管理 `.com` 域名的TLD DNS服务器。

   - **查询TLD DNS服务器**：
     - 接着，本地DNS服务器会向 `.com` 的TLD DNS服务器发出请求，询问 `baidu.com` 的IP地址。TLD服务器会告诉它，`baidu.com` 属于一个特定的**权威DNS服务器**（也就是负责具体域名的DNS服务器）。

   - **查询权威DNS服务器**：
     - 最后，本地DNS服务器会查询负责 `baidu.com` 的权威DNS服务器。权威DNS服务器会直接返回 `www.baidu.com` 对应的IP地址（例如：`220.181.57.216`）。

4. **缓存结果**

   - 一旦获得了 `www.baidu.com` 的IP地址，本地DNS服务器会将这个结果缓存一段时间，以便下次相同的查询可以更快速地完成。

   - 同时，计算机会将这个IP地址缓存到本地，以便以后再次访问 `www.baidu.com` 时能直接使用缓存的IP地址，而无需重新查询。

5. **访问目标网站**
   - 计算机获取到IP地址后，它会直接通过该IP地址向百度的服务器发起连接请求，并通过TCP/IP协议进行数据传输，从百度的服务器获取网页内容，最终展示在你的浏览器上。

`/ifcfg-enxx 的内容`

```shell
...
IPADDR=10.1.12.236
PREFIX=24
GATEWAY=10.1.12.254
DNS1=192.168.30.1
...
```

像这其中的DNS1，其实对应的是DNS服务器的地址，想翻译域名的时候就发送请求到这个服务器内找。1代表首选，如果有备用就是DNS2。





## 4.网络接口配置文件相关问题

#### 4.1 配置内的疑问

**RedHat/CentOS**：进入配置`cat /etc/sysconfig/network-scripts/ifcfg-ensxx` 

```shell
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none								# 仅影响 DHCPv4 地址的分配，不会阻止 DHCPv6 的使用
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes								# 开启系统在启动时初始化 IPv6
IPV6_AUTOCONF=no							# 设备会尝试通过 IPv6 的 SLAAC 自动配置一个 IPv6 地址
IPV6_DEFROUTE=yes							# 默认启用 IPv6 默认路由
IPV6_FAILURE_FATAL=no						# 表示如果 IPv6 配置失败，不会导致网络接口完全不可用
IPV6_ADDR_GEN_MODE=stable-privacy			# 指定 IPv6 地址的生成方式，内网可不加，原因在下方
NAME=ens192
UUID=4adf0269-d712-3e19-b4c4-f35f9ea6cf4f
ONBOOT=yes
AUTOCONNECT_PRIORITY=-999
IPADDR=10.1.12.223							# 静态配置，自己手动自定ip地址
PREFIX=24									# 指子网掩码的长度，可用 IPADDR=10.1.12.236/24 将配置省略
GATEWAY=10.1.12.254
DNS1=192.168.30.1
PEERDNS=no
IPV6ADDR=10:1:12:0:2b9f:8e7d:b93e:c223/64	# 配置正确，就是包含了两个消息，ip和掩码一起配置了；静态分配后，其他自动分配就无需配置，因为静态配置会覆盖这些自动获取的设置。
```

- `IPV6_INIT=no`作用是关闭或禁用 IPv6 协议栈的初始化，意味着系统启动时不会启用 IPv6 地址和相关的配置。这通常用于**完全禁用** IPv6 网络功能。

- `IPV6_DHCP=yes`，如果希望通过 DHCPv6 来获取 IPv6 地址，并且网络中有 DHCPv6 服务器，你可以将 `IPV6PEERDNS` 等选项启用并依赖 DHCPv6 来配置 DNS 和路由等。
   需要确保在网络接口配置文件中正确指定了启用 DHCPv6（例如，`IPV6_DHCP=yes`），或者使用一个单独的 DHCPv6 配置。

- `IPV6_PEERDNS=yes` 和 `IPV6_PEERROUTES=yes`：这些配置表示，如果 DHCPv6 被启用，系统将尝试从 DHCPv6 服务器获取 DNS 和路由信息。

- `IPV6_ADDR_GEN_MODE=stable-privacy`在 IPv6 中，设备的地址可以通过不同的方式生成。这个配置项控制的是设备如何生成其 **链路本地地址**（Link-local address）以及 **全局地址**（Global address）。

  IPV6_ADDR_GEN_MODE 可以设置为以下几种模式：

  1. stable-privacy：
     - **稳定隐私地址**。
       这个模式下，IPv6 地址会根据设备的 **MAC 地址**（或其他唯一标识符）生成，但会在 **隐私性**上做处理。
       换句话说，地址中的某些部分（如后缀部分）会使用随机数进行变化，从而避免通过地址推断出设备的身份。
     - 这种方式能确保生成的 IPv6 地址具有一定的 **隐私性**（防止跟踪），同时也保持了地址的 **稳定性**（即同一设备每次重新连接时生成相同的地址）。
     - 这是 **IPv6 隐私扩展（Privacy Extensions）** 的一种实现方式。
  2. **`eui64`**：使用 **MAC 地址**（通过 EUI-64 格式）来生成 IPv6 地址。这种方式下，地址在生成时会基于硬件的 MAC 地址，因此每个设备的地址都是固定的，容易被追踪。
  3. random：随机生成 IPv6 地址后缀（64位）。这种方式最大程度上保证了隐私性，但可能会在某些情况下导致网络中地址的稳定性和可识别性较差。
  4. none：不使用任何隐私扩展，完全依赖于 **系统默认的地址生成方式**，这通常就是直接基于 MAC 地址或其他标识符生成地址。

  在内网中**隐私性**通常不是一个优先考虑的需求，不增加它也是简化配置。所以不增加这个配置采用默认的生成方式（eui64）即可。

- `PREFIX=24` 是指子网掩码的长度，它表示网络地址部分的位数。
  - PREFIX=24 表示子网掩码有 **24 位**，即网络部分占用 24 位。
  - 在 IPv4 中，子网掩码通常表示为 255.255.255.0 对应的二进制形式：`11111111.11111111.11111111.00000000`。
  - `24` 就是这个二进制形式中 "1" 的个数，也就是前 24 位是网络地址，剩下的 8 位是主机地址。



**那我能直接修改 IPv4 和 IPv6 的地址吗？算自定义分配吗？**

其实就是静态配置了IP，如果是这样，那么其他相关的自动分配就无需配置，因为会被静态的覆盖。



**DHCPv4 和 DHCPv6 对应的配置为何不同？** v4是 BOOTPROTO，而v6是 IPV6_PEERDNS 或是 IPV6_AUTOCONF。

1. `BOOTPROTO`的配置仅作用于IPv4的分配，因为早期的设计，仅有配合DHCP才能分配地址
    BOOTPROTO 是为了配置 **IPv4** 地址自动获取的选项，尤其是通过 **DHCP**，因为在早期，IPv4 地址主要依赖 DHCP 进行动态分配。因此，`BOOTPROTO` 只作用于 IPv4 配置，无法直接用于 IPv6。
2. `BOOTPROTO`不作用于IPv6的原因是IPv6有两种生成地址的方式，一种是DHCP，另一种是SLAAC，所以控制IPv6的DHCP需要单独的配置
    IPv6 有 **SLAAC** 和 **DHCPv6** 两种地址生成方式。SLAAC 是自动生成地址的机制，而 DHCPv6 是为了更复杂的网络配置需求（如获取 DNS 等）。由于这两种方式的存在，IPv6 的 DHCP 配置需要单独通过 `IPV6_DHCP` 等参数来控制，而不是通过 `BOOTPROTO` 来进行。



**SLAAC 和 DHCP 分别是什么？**

1. **SLAAC**（Stateless Address Autoconfiguration - **无状态地址自动配置**）

   无需依赖服务器的IPv6地址自动配置方法。可以`通过网络上的路由器`自动获取其IPv6地址及相关配置信息。

- 工作原理：

  - 无状态配置：SLAAC是"无状态"的，因为它不依赖于中心服务器来分配地址。设备直接通过路由器广告消息（Router Advertisement，RA）来获取配置信息。

  - **地址生成**：设备使用 **Router Advertisement** 消息中的前缀信息和自己的 **MAC 地址** 来生成唯一的IPv6地址。具体来说，设备会将该前缀和其 **接口标识符**（通常是基于MAC地址生成的）结合，形成完整的IPv6地址。

  - 路由器广告（RA）：路由器会周期性地发送 RA 消息，这些消息包含了网络前缀、默认网关等信息。

  - 无服务器依赖：SLAAC 不需要 DHCP 服务器，也不会维护状态信息。设备自行生成地址，而无需中间服务器的帮助。

- SLAAC的优点：

  - 配置简单：设备可以自动配置IPv6地址，不依赖外部服务器。

  - 高效：适用于小型网络或不需要复杂配置的场景。

- SLAAC的缺点：

  - 仅提供最基本的地址配置，**不包含**如DNS服务器等其他信息（虽然可以通过 RA 消息中带上 DNS 信息，通常是可选的）。
  - 没有集中管理，可能会导致地址分配冲突或不一致。

2. **DHCPv6**（Dynamic Host Configuration Protocol for IPv6 - **IPv6动态主机配置协议**）

   是一种与 **DHCP** 类似的协议，但它是为IPv6网络设计的。DHCPv6可以为设备分配地址以及其他网络配置信息（如DNS服务器地址、域名、时间服务器等）。

- 工作原理：
  - 有状态配置：与SLAAC不同，DHCPv6是“有状态”的，因为它依赖于DHCPv6服务器。设备向DHCPv6服务器请求配置信息，并由服务器返回分配的地址和其他配置信息。
  - 客户端请求：设备向网络中的DHCPv6服务器发送请求，获取地址以及其他相关信息（如DNS）。
  - 服务器分配：DHCPv6服务器会为设备分配IPv6地址、DNS服务器地址、域名等信息，并可以提供租约时间等状态信息。
  - 可选性：DHCPv6可以与SLAAC结合使用，提供更为丰富的配置，或者单独使用。
- DHCPv6的优点：
  - 集中管理：可以集中管理IPv6地址分配和网络配置信息，适用于大规模网络或需要精确控制的环境。
  - 提供更多配置信息：不仅可以分配IPv6地址，还可以提供DNS、时间服务器等其他配置信息。
  - 有状态管理：有状态的地址分配能够更好地控制地址池和租约管理，避免冲突。
- DHCPv6的缺点：
  - 配置复杂：需要部署和维护DHCPv6服务器。
  - 依赖服务器：如果DHCPv6服务器不可用，设备将无法获取地址。

3. **SLAAC 和 DHCPv6 的结合**

   在实际网络中，SLAAC 和 DHCPv6 可以一起使用，以提供更完整的配置功能。例如：

   - **SLAAC** 用于自动配置IPv6地址和前缀。
   - **DHCPv6** 用于提供其他配置信息，如DNS服务器地址、域名等。



**将 IPv4 和 IPv6 的 DEFROUTE 配置都开启会互相影响吗？**

不会。（最多的间接影响，就是路由优先级、网络的支持）

- 因为它们是独立的协议栈，处理自己的路由表和路由逻辑。
  在同一台机器上同时配置 IPv4 和 IPv6 的默认路由，这两者的路由配置会分别管理自己的网络流量。



:book::dango:

#### 4.2 **为什么能看到多个ipv6的地址**

若想只看ipv6的ip用`ip -6 addr show`

```shell
[root@k8s-host223 network-scripts]# ip addr show ens192
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:9f:cc:83 brd ff:ff:ff:ff:ff:ff
    inet 10.1.12.223/24 brd 10.1.12.255 scope global noprefixroute ens192
       valid_lft forever preferred_lft forever
    inet6 10:1:12:0:2b9f:8e7d:b93e:c223/64 scope global noprefixroute 
       valid_lft forever preferred_lft forever
    inet6 fe80::3741:85b8:cd0d:e472/64 scope link dadfailed tentative noprefixroute 
       valid_lft forever preferred_lft forever
    inet6 fe80::1299:6678:5aaf:6399/64 scope link dadfailed tentative noprefixroute 
       valid_lft forever preferred_lft forever
    inet6 fe80::e09a:44df:36da:43c1/64 scope link dadfailed tentative noprefixroute 
       valid_lft forever preferred_lft forever
```

这种情况是正常现象，尤其是在使用Linux系统的虚机上。为什么会有这么多个IPv6地址：

1. **全球唯一IPv6地址**

```powershell
inet6 10:1:12:0:2b9f:8e7d:b93e:c223/64 scope global noprefixroute
# 或者
inet6 10:1:12:0:2b9f:8e7d:b93e:c223/64 scope global dynamic noprefixroute
```

这是一个全球唯一的IPv6地址，

- `dynamic`：通常是由DHCPv6或者自动配置（SLAAC）生成的，不是手动配置的静态地址。

- `noprefixroute`：这个标志说明系统不会自动为该地址的前缀（即 `10:1:12:0::/64`）添加路由。
  换句话说，虽然设备获取到了这个全局地址，但操作系统不会为它自动创建与其网络前缀相关的路由条目。

- `dynamic noprefixroute`：**动态分配的 IPv6 地址**，但操作系统避免自动为该地址的前缀添加路由。

- `前缀`就是用来定义地址的网络部分，而**前缀长度**（如 `/64`）则指明网络部分的长度。



2. **链路本地IPv6地址**

```powershell
inet6 fe80::3741:85b8:cd0d:e472/64 scope link
inet6 fe80::1299:6678:5aaf:6399/64 scope link
inet6 fe80::e09a:44df:36da:43c1/64 scope link
```

这些地址是链路本地地址（Link-Local Address），以 `fe80::/10` 为前缀。链路本地地址**用于设备之间在同一链路上（局域网或同一虚拟机环境）进行通信**。每个接口在启用IPv6时都会自动生成一个链路本地地址。多个链路本地地址的出现通常是由于多次尝试自动配置或系统尝试生成新的地址（例如与不同的虚拟网卡接口或虚拟机镜像相关）。

3. **DAD失败和Tentative状态**

```powershell
dadfailed tentative
```

这些标记表示“冲突检测”过程（DAD，Duplicate Address Detection）出现了问题，或者IPv6地址处于“尝试”状态（tentative），未完全确认或被其他设备占用。通常，这种情况发生在多个网络接口（如虚拟机或多网卡环境）尝试生成相同的链路本地地址时。

**为什么会有多个地址？**

- **虚拟机网络配置**：虚拟机的网络接口可能存在多个虚拟适配器或者多个网络适配器，它们分别生成了多个链路本地地址。

- **IPv6配置问题**：有时，系统在某些网络条件下可能尝试多次配置IPv6地址，而某些地址可能会出现冲突（尤其是链路本地地址）。DAD检测失败时，会标记为“tentative”或“dadfailed”状态。

- **操作系统的自动化配置机制**：操作系统会根据其配置机制（如SLAAC或DHCPv6）自动生成IPv6地址。

  

禁用方式

1. **禁用IPv6**：如果你不需要IPv6地址，可以通过禁用IPv6来避免这些问题。

   - 在Linux上，可以通过编辑

     ```
     /etc/sysctl.conf
     ```

     文件并添加以下行来禁用IPv6：

     ```shell
     net.ipv6.conf.all.disable_ipv6 = 1    # 相反 0 就是开启
     net.ipv6.conf.default.disable_ipv6 = 1
     ```

     然后运行

     ```
     sysctl -p
     ```

     使设置生效。

2. **手动配置IPv6地址**：你也可以手动配置IPv6地址，确保没有冲突，避免自动配置过程出现问题。







#### 4.3 子网掩码

平时所说的 **掩码** 或 **网段**，实际上就是我们在 IPv4 或 IPv6 网络中提到的 **子网掩码**（Subnet Mask）。

1. **简单解释：**

- 子网掩码（Subnet Mask）用来区分一个 IP 地址中的**网络部分**和**主机部分**。
  - 在 IPv4 中，通常使用四个字节（32 位）表示，例如 `255.255.255.0`，其中 `255` 表示网络部分，`0` 表示主机部分。
  - 在 IPv6 中，我们通常使用斜杠（`/`）后面跟一个数字来表示子网前缀，例如 `2001:db8::/64`，表示前 64 位是网络部分，剩下的 64 位是主机部分。

2. **具体情况：**

   1. **IPv4 子网掩码**：例如 `192.168.1.0/24`，这里 `/24` 表示前 24 位是网络部分，剩余 8 位是主机部分。
      - 网络部分：`192.168.1`，这是该网络的标识。
      - 主机部分：`0`，在这个子网内，可以分配给不同设备的地址范围通常是 `192.168.1.1` 到 `192.168.1.254`。

   1. **IPv6 子网掩码**：例如 `2001:db8::/64`，这里 `/64` 表示前 64 位是网络部分，剩下的 64 位是主机部分。
      - 网络部分：`2001:db8::`，这是该网络的标识。
      - 主机部分：后 64 位可以用于分配设备地址（例如 `2001:db8::1`, `2001:db8::2` 等）。



#### 4.4 私有地址段

**IPV4**

IPv4 私有地址包括以下三个段：

- `10.0.0.0/8`
- `172.16.0.0/12`（包括 `172.16.0.0` 到 `172.31.255.255`）
- `192.168.0.0/16`

这些地址是专门为局域网使用而设计的，不能在公共互联网中路由。



**IPV6**

ULA（**Unique Local Address**本地唯一地址）是专门用于 IPv6 的。

1. **`fc00::/7`**（包含 `fd00::/8` 和 `fc00::/8`）

   - `fc00::/7`是用于唯一本地地址（ULA）的地址范围。具体来说：
     - **`fd00::/8`** 是用于 **自定义的唯一本地地址**，可以在组织内部使用，不会在互联网中路由。
     - **`fc00::/8`** 是 **预留地址**，目前没有明确的用途，因此通常不会用于实际分配。
   - **ULA** 地址的目的是提供类似于 IPv4 私有地址（如 `10.0.0.0/8`, `172.16.0.0/12`）的功能，**但**它是为 IPv6 设计的。

   所以，`fd00::/8` 是 ULA 地址段的有效部分，而 `fc00::/8` 在目前是保留的，实际上尚未用于任何实际分配。

   

**其他 IPv6 地址类型**

IPv6 地址分为几种不同的类型，除了 ULA（`fd00::/8`）外，还有以下一些常见的地址类型：

1. **全球单播地址（Global Unicast Address）**
   - 范围：`2000::/3`（即从 `2000::` 到 `3FFF::`）
   - 这些地址用于在互联网上的全局通信，是可路由的地址，与 IPv4 中的公共地址类似。
2. **链路本地地址（Link-local Address）**
   - 范围：`fe80::/10`
   - 这些地址用于同一链路上的设备间通信，不可路由到其他网络。它们类似于 IPv4 中的 `169.254.0.0/16` 地址（APIPA）。
3. **多播地址（Multicast Address）**
   - 范围：`ff00::/8`
   - 用于多播通信，一种数据传输模式，允许数据发送到多个接收者。





## 5.Map.computeIfAbsent()

> computeIfAbsent 是 Java 8 引入的 Map 接口中的一个默认方法。
>
> 作用：如果指定的键在映射中不存在，则计算一个值并将其放入映射中；如果键已经存在，则返回该键对应的值。

“computeIfAbsent” 可以翻译为 “如果缺失则计算”。

具体来说， computeIfAbsent 方法的签名如下：

`V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);`

- key ：要查找的键。 

- mappingFunction ：一个函数，当键不存在时，用来计算该键的值。

>  使用 computeIfAbsent 的好处是，它可以减少代码的复杂性，避免显式地检查键是否存在，并且在计算值时是线程安全的。

```java
Map<String, List<String>> map = new HashMap<>();
// 使用 computeIfAbsent 方法
List<String> list = map.computeIfAbsent("key1", k -> new ArrayList<>());
list.add("value1");

// 此时 map 中的内容是：{"key1": ["value1"]}
```

在这个例子中，如果 "key1" 不存在，则会创建一个新的 ArrayList 并将其放入 map 中。然后，我们可以直接向这个列表中添加元素。



==**注意： 此方法获取的value是有关联关系的**==

应该是跟地址不会发生变动的所有value，都是有关系的

```java
System.out.println(map); // 输出: {"key1": []}
list.add("value1");
System.out.println(map); // 输出: {"key1": ["value1"]}
```

集合类型、对象类型的，地址都不变，内容修改会关联到maps中的内容。

而String， Integer等，修改后地址会发生变化，得要重新put。





## 6.System.identityHashCode(Object x)

**System.identityHashCode(Object x) 与 Object.hashCode() 的区别**

1. 计算方式： 

- System.identityHashCode(Object x)：返回对象的身份哈希码，实际上是返回对象在内存中的地址（或其某种形式的整数表示），与对象的内容无关。 

- bevan.hashCode()：返回对象 bevan 的哈希码，这是由类的 hashCode() 方法定义的。这个方法通常会根据对象的属性（字段）计算哈希码，具体实现取决于类的定义。

2. 用途： 

- System.identityHashCode(Object x)：常用于需要`比较对象身份（即内存地址）而非内容的场景`，例如在某些数据结构中（如哈希表）需要`确保对象的唯一性`。 

- bevan.hashCode()：通常用于`对象内容的比较和存储`，比如在集合类（如 HashSet、HashMap）中，使用 hashCode() 来`确定对象的存储位置`。 

3. 重写： 

- System.identityHashCode(Object x) 不会被重写，始终返回对象的身份哈希码。 

- bevan.hashCode() 可以被重写，以便根据对象的属性定义自定义的哈希码计算方式。 

**注意**：虽然 identityHashCode 反映了对象在内存中的身份，但它**并不等同于**实际的内存地址。**Java 不允许直接访问内存地址，这样做会破坏语言的安全性和平台独立性。**









## 7.免密登入

想要 174 和 172 之间免密登入

使用命令：`ssh-copy-id 10.1.12.172`

被提示输入远程主机 `10.1.12.172` 的用户密码。输入密码后，`ssh-copy-id` 会把本地公钥复制到远程主机的 `~/.ssh/authorized_keys` 文件中。完成后，你就可以直接通过 SSH 连接到远程主机，而无需每次都输入密码。



如果没有设置过 SSH 密钥对，或者需要生成新的密钥对，可以先执行 `ssh-keygen` 来生成密钥对。

例如：

1. 执行命令：

   ```shell
   ssh-keygen
   ```

2. 按提示选择路径（通常默认就可以按回车）：

   ```
   Enter file in which to save the key (/home/user/.ssh/id_rsa): [Press Enter]
   ```

3. 设置一个密码短语（可以按回车跳过，不设置密码）：

   ```shell
   Enter passphrase (empty for no passphrase): [Press Enter]
   ```

4. 确认密码短语（如果有设置）：

   ```shell
   Enter same passphrase again: [Press Enter]
   ```

完成后，会在 `~/.ssh/` 目录下生成两个文件：

- `id_rsa`：私钥，==**不要泄露给别人**==。
- `id_rsa.pub`：公钥，**可以共享给别人**，用来进行免密登录配置。

然后，通过使用 `ssh-copy-id` 将公钥复制到远程主机，或者手动将 `id_rsa.pub` 文件的内容添加到远程主机的 `~/.ssh/authorized_keys` 文件中。



















